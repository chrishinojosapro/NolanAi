<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Show Studio</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #3b82f6;
            --timeline-bg: #2a2a2a;
            --grid-color: #444;
            --cursor-color: #ff0000;
            --block-height: 60px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- HEADER --- */
        header {
            background: var(--panel-color);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        h1 { margin: 0; font-size: 1.2rem; display:flex; align-items:center; gap:10px; }
        
        .connection-status { font-size: 0.7rem; color: #666; border:1px solid #444; padding:2px 6px; border-radius:4px; text-transform: uppercase;}
        .connected { color: #22c55e; border-color: #22c55e; }

        button {
            padding: 8px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            background: #333;
            color: #ddd;
            transition: 0.2s;
            font-size: 0.9rem;
        }
        button:hover { background: #444; }
        button:active { transform: translateY(1px); }
        button.primary { background: var(--accent-color); color: white; }
        button.danger { background: #ef4444; color: white; }
        button.success { background: #22c55e; color: white; }
        
        /* --- WORKSPACE --- */
        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        /* --- TOOLBAR --- */
        .toolbar {
            display: flex;
            gap: 10px;
            background: var(--panel-color);
            padding: 10px;
            border-radius: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .tool-group {
            display: flex;
            gap: 5px;
            border-right: 1px solid #444;
            padding-right: 10px;
            align-items: center;
        }
        .tool-group:last-child { border: none; }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background: #252525;
        }
        .tool-btn.active {
            border-color: var(--accent-color);
            background: #333;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* --- TIMELINE AREA --- */
        .timeline-container {
            flex: 1;
            background: var(--timeline-bg);
            border-radius: 8px;
            position: relative;
            overflow-x: scroll;
            overflow-y: hidden;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        /* The scrolling wrapper for the canvas */
        .timeline-scroll-area {
            height: 100%;
            min-width: 100%;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* Playhead Cursor */
        #playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: var(--cursor-color);
            pointer-events: none;
            z-index: 10;
        }

        /* --- FOOTER / TRANSPORT --- */
        .transport-bar {
            background: var(--panel-color);
            padding: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            border-top: 1px solid #333;
        }

        .time-display {
            font-family: monospace;
            font-size: 1.2rem;
            color: var(--accent-color);
            min-width: 80px;
            text-align: center;
        }

        input[type="file"] {
            font-size: 0.8rem;
            color: #888;
        }
        
        .help-text {
            font-size: 0.8rem;
            color: #666;
            margin-left: auto;
        }

    </style>
</head>
<body>

    <header>
        <div style="display:flex; align-items:center;">
            <h1>LightStudio</h1>
            <span id="connectionStatus" class="connection-status">Disconnected</span>
        </div>
        <div style="display:flex; gap:10px;">
            <button onclick="saveProject()">üíæ Save Show</button>
            <button onclick="document.getElementById('loadInput').click()">üìÇ Load Show</button>
            <input type="file" id="loadInput" accept=".json" style="display:none" onchange="loadProject(this)">
            
            <select id="protocolSelect" style="background:#333; color:white; border:none; padding:8px; border-radius:6px;">
                <option value="1">Protocol: Lotus/Keepsmile (Most Common)</option>
                <option value="0">Protocol: ELK-BLEDOM (Standard)</option>
                <option value="2">Protocol: Triones</option>
            </select>
            
            <button id="connectBtn" class="primary">üì° Connect Light</button>
        </div>
    </header>

    <div class="workspace">
        
        <!-- AUDIO LOAD -->
        <div style="display:flex; justify-content:space-between; align-items:center; background:#252525; padding:10px; border-radius:8px;">
            <div>
                <span style="font-size:0.8rem; color:#aaa; margin-right:10px;">üéµ Soundtrack:</span>
                <input type="file" id="audioFile" accept="audio/*">
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
                <button class="success" id="manualOnBtn">FORCE ON</button>
                <button class="danger" id="manualOffBtn">FORCE OFF</button>
                <span style="font-size:0.8rem; color:#aaa;">Zoom:</span>
                <input type="range" id="zoomRange" min="10" max="300" value="100" style="width:100px;">
            </div>
        </div>

        <!-- TOOLBAR -->
        <div class="toolbar">
            
            <div class="tool-group">
                <button class="tool-btn active" id="tool-select" onclick="setTool('select')" title="Select/Move/Delete (Backspace)">‚úã</button>
            </div>

            <div class="tool-group">
                <input type="color" id="toolColor" value="#ff0000" title="Pick Color">
                <button class="tool-btn" id="tool-paint" onclick="setTool('paint')" title="Paint Color Block (Drag)">üñåÔ∏è</button>
            </div>

            <div class="tool-group">
                <button class="tool-btn" id="tool-flash" onclick="setTool('flash')" style="color:yellow;" title="Flash Event (Click)">‚ö°</button>
                <button class="tool-btn" id="tool-clash" onclick="setTool('clash')" style="color:white;" title="Clash Event (Click)">üí•</button>
                <button class="tool-btn" id="tool-off" onclick="setTool('off')" style="color:gray;" title="Turn Off Block (Drag)">‚ö´</button>
            </div>
            
            <div class="help-text" id="toolHelp">Select Tool: Click to move events</div>
        </div>

        <!-- TIMELINE -->
        <div class="timeline-container" id="timelineContainer">
            <div class="timeline-scroll-area" id="scrollArea">
                <canvas id="timelineCanvas"></canvas>
                <div id="playhead"></div>
            </div>
        </div>

    </div>

    <div class="transport-bar">
        <button onclick="stopPlayback()">‚èπ Stop</button>
        <button class="primary" id="playBtn" onclick="togglePlayback()" style="width: 100px;">‚ñ∂ Play</button>
        <div class="time-display" id="timeDisplay">00:00.0</div>
    </div>

    <!-- Hidden Audio Player -->
    <audio id="audioPlayer"></audio>

    <script>
        // --- CONSTANTS & CONFIG ---
        const PX_PER_SEC_BASE = 50; // Pixels per second at 100% zoom
        let PX_PER_SEC = 100; // Current zoom
        const TRACK_HEIGHT = 150;
        
        // --- STATE ---
        let events = []; // Array of { id, type, start, duration, color }
        let currentTool = 'select';
        let selectedEventId = null;
        let isPlaying = false;
        let audioDuration = 60; // Default until loaded
        let waveformData = null; // Uint8Array of peaks
        
        // --- BLUETOOTH STATE ---
        let device, characteristic;
        let currentProtocolIndex = 1; // Default to Lotus
        let lastSentColor = null;

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('timelineCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('timelineContainer');
        const playhead = document.getElementById('playhead');
        const audioPlayer = document.getElementById('audioPlayer');
        const timeDisplay = document.getElementById('timeDisplay');
        const toolHelp = document.getElementById('toolHelp');

        // --- PROTOCOLS ---
        const PROTOCOLS = [
            { // 0: ELK
                name: "ELK",
                write: (r,g,b) => new Uint8Array([0x56, r, g, b, 0x00, 0xf0, 0xaa]),
                off: new Uint8Array([0xcc, 0x24, 0x33]),
                on: new Uint8Array([0xcc, 0x23, 0x33])
            },
            { // 1: Lotus/Keepsmile (0x7E)
                name: "Lotus",
                write: (r,g,b) => new Uint8Array([0x7e, 0x07, 0x05, 0x03, r, g, b, 0x10, 0xef]),
                off: new Uint8Array([0x7e, 0x04, 0x04, 0x00, 0x00, 0x00, 0xff, 0x00, 0xef]),
                on: new Uint8Array([0x7e, 0x04, 0x04, 0xf0, 0x00, 0x01, 0xff, 0x00, 0xef])
            },
            { // 2: Triones
                name: "Triones",
                write: (r,g,b) => new Uint8Array([0x56, r, g, b, 0x00, 0xf0, 0xaa]),
                off: new Uint8Array([0xcc, 0x24, 0x33]),
                on: new Uint8Array([0xcc, 0x23, 0x33])
            }
        ];

        // --- INITIALIZATION ---
        function resizeCanvas() {
            canvas.height = container.clientHeight;
            canvas.width = Math.max(container.clientWidth, audioDuration * PX_PER_SEC);
            drawTimeline();
        }
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('zoomRange').addEventListener('input', (e) => {
            PX_PER_SEC = parseInt(e.target.value);
            resizeCanvas();
        });

        document.getElementById('protocolSelect').addEventListener('change', (e) => {
            currentProtocolIndex = parseInt(e.target.value);
        });

        // --- TOOL LOGIC ---
        window.setTool = function(tool) {
            currentTool = tool;
            
            // UI Updates
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tool-'+tool).classList.add('active');
            
            // Help Text
            const help = {
                'select': 'Click to Select. Drag to Move. Edge to Resize. Backspace to Delete.',
                'paint': 'Click & Drag on timeline to create a COLOR block.',
                'flash': 'Click to insert a short FLASH (Strike).',
                'clash': 'Click to insert a CLASH (White explosion).',
                'off': 'Click & Drag to create an OFF block (Darkness).'
            };
            toolHelp.innerText = help[tool] || '';
        };

        // --- AUDIO HANDLING ---
        document.getElementById('audioFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if(!file) return;
            
            const url = URL.createObjectURL(file);
            audioPlayer.src = url;
            
            // Decode for waveform
            const arrayBuffer = await file.arrayBuffer();
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            
            audioDuration = audioBuffer.duration;
            
            // Generate waveform data (simplified)
            const rawData = audioBuffer.getChannelData(0);
            const samples = 2000; // Resolution
            const blockSize = Math.floor(rawData.length / samples);
            waveformData = new Float32Array(samples);
            
            for(let i=0; i<samples; i++) {
                let sum = 0;
                for(let j=0; j<blockSize; j++) {
                    sum += Math.abs(rawData[i*blockSize + j]);
                }
                waveformData[i] = sum / blockSize;
            }
            
            resizeCanvas();
        });

        // --- CANVAS INTERACTION ---
        let isDragging = false;
        let dragStartTime = 0;
        let dragEvent = null;
        let dragAction = null; // 'move', 'resize-left', 'resize-right', 'create'

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const time = x / PX_PER_SEC;
            
            if (currentTool === 'select') {
                // Check for click on event
                const clickedEvent = events.find(ev => time >= ev.start && time <= ev.start + ev.duration);
                
                if (clickedEvent) {
                    selectedEventId = clickedEvent.id;
                    isDragging = true;
                    dragEvent = clickedEvent;
                    
                    // Check edges for resize
                    const edgeThreshold = 5 / PX_PER_SEC; // 5 pixels
                    if (Math.abs(time - clickedEvent.start) < edgeThreshold) dragAction = 'resize-left';
                    else if (Math.abs(time - (clickedEvent.start + clickedEvent.duration)) < edgeThreshold) dragAction = 'resize-right';
                    else dragAction = 'move';
                    
                    dragStartTime = time;
                } else {
                    // Clicked empty space - move playhead (preview)
                    audioPlayer.currentTime = time;
                    updatePlayhead();
                    selectedEventId = null;
                }
            } 
            else if (['paint', 'off'].includes(currentTool)) {
                // CREATE BLOCK
                isDragging = true;
                dragAction = 'create';
                dragStartTime = time;
                
                const newEvent = {
                    id: Date.now(),
                    type: currentTool === 'paint' ? 'color' : 'off',
                    start: time,
                    duration: 0.5, // Default width
                    color: currentTool === 'paint' ? document.getElementById('toolColor').value : '#000000'
                };
                events.push(newEvent);
                selectedEventId = newEvent.id;
                dragEvent = newEvent;
            }
            else if (['flash', 'clash'].includes(currentTool)) {
                // CREATE INSTANT
                const newEvent = {
                    id: Date.now(),
                    type: currentTool,
                    start: time,
                    duration: 0.15, // Short fixed duration
                    color: currentTool === 'flash' ? '#ffff00' : '#ffffff'
                };
                events.push(newEvent);
                selectedEventId = newEvent.id;
                drawTimeline();
            }
            
            drawTimeline();
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            // Constrain x within canvas
            if (x < 0) x = 0; 
            const time = Math.max(0, x / PX_PER_SEC);
            
            if (dragAction === 'move') {
                const dt = time - dragStartTime;
                dragEvent.start += dt;
                dragStartTime = time;
            } 
            else if (dragAction === 'resize-right' || dragAction === 'create') {
                let newDur = time - dragEvent.start;
                if(newDur < 0.1) newDur = 0.1;
                dragEvent.duration = newDur;
            }
            else if (dragAction === 'resize-left') {
                const end = dragEvent.start + dragEvent.duration;
                let newStart = time;
                if (newStart > end - 0.1) newStart = end - 0.1;
                dragEvent.duration = end - newStart;
                dragEvent.start = newStart;
            }
            
            drawTimeline();
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            dragEvent = null;
            dragAction = null;
        });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace' || e.key === 'Delete') {
                if (selectedEventId) {
                    events = events.filter(ev => ev.id !== selectedEventId);
                    selectedEventId = null;
                    drawTimeline();
                }
            }
            if (e.code === 'Space') {
                e.preventDefault();
                togglePlayback();
            }
        });

        // --- DRAWING ---
        function drawTimeline() {
            // Clear
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Audio Waveform (Background)
            if (waveformData) {
                ctx.fillStyle = '#333';
                const step = canvas.width / waveformData.length;
                const mid = canvas.height / 2;
                const scale = canvas.height * 0.4;
                
                ctx.beginPath();
                for(let i=0; i<waveformData.length; i++) {
                    const x = i * step;
                    const h = waveformData[i] * scale;
                    ctx.rect(x, mid - h, step, h*2);
                }
                ctx.fill();
            }

            // 2. Draw Grid (Seconds)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let sec = 0; sec < audioDuration; sec++) {
                const x = sec * PX_PER_SEC;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.fillStyle = '#666';
                ctx.fillText(sec + 's', x + 5, 12);
            }
            ctx.stroke();

            // 3. Draw Events
            events.forEach(ev => {
                const x = ev.start * PX_PER_SEC;
                const w = ev.duration * PX_PER_SEC;
                const y = 30;
                const h = 80;

                // Block Body
                ctx.fillStyle = ev.color;
                
                // Visual tweaks for types
                if (ev.type === 'off') {
                    ctx.fillStyle = '#111'; // Black block
                    ctx.strokeStyle = '#555';
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(x, y, w, h);
                    ctx.setLineDash([]);
                    ctx.fillRect(x, y, w, h);
                } else if (ev.type === 'flash' || ev.type === 'clash') {
                    // Gradient for impulse events
                    const grad = ctx.createLinearGradient(x, y, x, y+h);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(1, ev.color);
                    ctx.fillStyle = grad;
                    ctx.fillRect(x, y, w, h);
                } else {
                    // Standard Color Block
                    ctx.fillRect(x, y, w, h);
                }

                // Selection Border
                if (ev.id === selectedEventId) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                }
                
                // Label
                ctx.fillStyle = (ev.type === 'off' || ev.color === '#000000') ? '#aaa' : 'black';
                ctx.font = '10px sans-serif';
                ctx.fillText(ev.type.toUpperCase(), x + 3, y + 12);
            });
        }

        // --- PLAYBACK ENGINE ---
        function togglePlayback() {
            if (isPlaying) stopPlayback();
            else startPlayback();
        }

        function startPlayback() {
            if(!audioPlayer.src) return alert("Load Audio First!");
            isPlaying = true;
            audioPlayer.play();
            document.getElementById('playBtn').innerText = '‚è∏ Pause';
            requestAnimationFrame(playbackLoop);
        }

        function stopPlayback() {
            isPlaying = false;
            audioPlayer.pause();
            document.getElementById('playBtn').innerText = '‚ñ∂ Play';
            
            // Optional: Send OFF when stopping
            if(characteristic) {
                const p = PROTOCOLS[currentProtocolIndex];
                characteristic.writeValue(p.off).catch(e=>{});
            }
        }

        let lastEventSent = null;

        function playbackLoop() {
            if (!isPlaying) return;

            const t = audioPlayer.currentTime;
            updatePlayhead();
            
            // Check for events at this time
            // Find the event that should be active NOW
            // We sort by start time to prioritize layering if needed, but here simple find is ok
            const activeEvent = events.find(ev => t >= ev.start && t < (ev.start + ev.duration));

            if (activeEvent) {
                // Optimization: Only send bluetooth command if event CHANGED
                if (activeEvent.id !== lastEventSent) {
                    sendEvent(activeEvent);
                    lastEventSent = activeEvent.id;
                }
            } else {
                // No event currently active? 
                // Do we want default behavior? Maybe last known color?
                // For now, if we leave an event, we don't necessarily send OFF unless an OFF block exists.
                // Reset tracker so next event triggers
                if (lastEventSent !== null) lastEventSent = null; 
            }

            requestAnimationFrame(playbackLoop);
        }

        function updatePlayhead() {
            const t = audioPlayer.currentTime;
            const x = t * PX_PER_SEC;
            playhead.style.transform = `translateX(${x}px)`;
            
            // Auto scroll if playhead goes off screen
            const scrollL = container.scrollLeft;
            const width = container.clientWidth;
            if (x > scrollL + width * 0.8) {
                container.scrollLeft = x - width * 0.2;
            }
            
            // Time display
            const mins = Math.floor(t / 60);
            const secs = Math.floor(t % 60).toString().padStart(2, '0');
            const ms = Math.floor((t % 1) * 10);
            timeDisplay.innerText = `${mins}:${secs}.${ms}`;
        }

        // --- BLUETOOTH LOGIC ---
        async function sendEvent(ev) {
            if (!characteristic) return;
            
            const p = PROTOCOLS[currentProtocolIndex];

            if (ev.type === 'off') {
                try {
                    await characteristic.writeValue(p.off);
                    console.log("Sent OFF");
                } catch(e) { console.log(e); }
            } else {
                // It's a color/flash/clash event. 
                // Ensure ON first, then Color.
                // We construct the color payload
                const hex = ev.color;
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                const colorData = p.write(r, g, b);

                try {
                    // Send ON first to ensure it wakes up
                    // Some chips ignore color commands if in 'soft off' state
                    if (p.on) {
                        await characteristic.writeValue(p.on);
                        // Small delay might be needed for the chip to process, 
                        // but JS execution usually provides enough gap or the BLE stack handles the queue.
                        // To be safe, we can just await.
                    }
                    
                    // Send Color
                    await characteristic.writeValue(colorData);
                    console.log(`Sent RGB: ${r},${g},${b}`);
                } catch (err) {
                    console.log("BT Error", err);
                }
            }
        }
        
        // Manual controls logic
        document.getElementById('manualOffBtn').addEventListener('click', () => {
             if(characteristic) {
                 const p = PROTOCOLS[currentProtocolIndex];
                 characteristic.writeValue(p.off).catch(e=>{});
             }
        });
        
        document.getElementById('manualOnBtn').addEventListener('click', () => {
             if(characteristic) {
                 const p = PROTOCOLS[currentProtocolIndex];
                 if(p.on) characteristic.writeValue(p.on).catch(e=>{});
             }
        });

        document.getElementById('connectBtn').addEventListener('click', async () => {
            const status = document.getElementById('connectionStatus');
            try {
                if (!navigator.bluetooth) throw new Error("Browser not supported. Use Bluefy (iOS) or Chrome (Desktop).");
                
                status.innerText = "Scanning...";
                
                device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [
                        '0000ffd5-0000-1000-8000-00805f9b34fb', 
                        '0000ffe5-0000-1000-8000-00805f9b34fb',
                        '0000fff0-0000-1000-8000-00805f9b34fb'
                    ]
                });

                const server = await device.gatt.connect();
                
                // Try to find the right service based on standard UUIDs
                // This is a simplified scanner logic from before
                const uuids = [
                    '0000ffd5-0000-1000-8000-00805f9b34fb', 
                    '0000ffe5-0000-1000-8000-00805f9b34fb',
                    '0000fff0-0000-1000-8000-00805f9b34fb'
                ];
                
                let service;
                for(let u of uuids) {
                    try { service = await server.getPrimaryService(u); break; } catch(e){}
                }
                if(!service) throw new Error("Service not found");

                const charUUIDs = [
                    '0000ffd9-0000-1000-8000-00805f9b34fb',
                    '0000ffe9-0000-1000-8000-00805f9b34fb',
                    '0000fff3-0000-1000-8000-00805f9b34fb'
                ];
                
                for(let c of charUUIDs) {
                    try { characteristic = await service.getCharacteristic(c); break; } catch(e){}
                }
                
                if (characteristic) {
                    status.innerText = "Connected: " + device.name;
                    status.classList.add('connected');
                    document.getElementById('connectBtn').style.display = 'none';
                } else {
                    throw new Error("Characteristic not found");
                }

            } catch (err) {
                alert("Connection failed: " + err.message);
                status.innerText = "Error";
            }
        });

        // --- SAVE / LOAD ---
        window.saveProject = function() {
            const data = JSON.stringify(events);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lightshow.json';
            a.click();
        };

        window.loadProject = function(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    events = JSON.parse(e.target.result);
                    drawTimeline();
                } catch(err) { alert("Invalid File"); }
            };
            reader.readAsText(file);
        };

        // Initial Draw
        resizeCanvas();

    </script>
</body>
</html>
