<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Show Studio v9 (Token Fix)</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #3b82f6;
            --magic-color: #8b5cf6;
            --ai-color: #10b981;
            --timeline-bg: #2a2a2a;
            --grid-color: #444;
            --cursor-color: #ff0000;
            --block-height: 60px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- HEADER --- */
        header {
            background: var(--panel-color);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        h1 { margin: 0; font-size: 1.2rem; display:flex; align-items:center; gap:10px; }
        
        .connection-status { font-size: 0.7rem; color: #666; border:1px solid #444; padding:2px 6px; border-radius:4px; text-transform: uppercase;}
        .connected { color: #22c55e; border-color: #22c55e; }

        button {
            padding: 8px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            background: #333;
            color: #ddd;
            transition: 0.2s;
            font-size: 0.9rem;
        }
        button:hover { background: #444; }
        button:active { transform: translateY(1px); }
        button.primary { background: var(--accent-color); color: white; }
        button.danger { background: #ef4444; color: white; }
        button.success { background: #22c55e; color: white; }
        button.battle { background: #eab308; color: black; } 
        button.fire { background: #f97316; color: white; }
        button.ai { background: var(--ai-color); color: white; }
        
        /* --- WORKSPACE --- */
        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        /* --- TOOLBAR --- */
        .toolbar {
            display: flex;
            gap: 10px;
            background: var(--panel-color);
            padding: 10px;
            border-radius: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .tool-group {
            display: flex;
            gap: 5px;
            border-right: 1px solid #444;
            padding-right: 10px;
            align-items: center;
        }
        .tool-group:last-child { border: none; }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background: #252525;
        }
        .tool-btn.active {
            border-color: var(--accent-color);
            background: #333;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
        }
        
        /* Magic Tool Specifics */
        #tool-magic.active { border-color: var(--magic-color); box-shadow: 0 0 10px rgba(139, 92, 246, 0.3); }
        
        .magic-controls {
            display: none;
            flex-direction: column;
            gap: 2px;
        }
        .magic-controls.visible { display: flex; }
        .magic-input { 
            width: 60px; background: #111; border: 1px solid #444; color: white; padding: 2px; font-size: 0.7rem; 
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* --- TIMELINE AREA --- */
        .timeline-container {
            flex: 1;
            background: var(--timeline-bg);
            border-radius: 8px;
            position: relative;
            overflow-x: scroll;
            overflow-y: hidden;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .timeline-scroll-area {
            height: 100%;
            min-width: 100%;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: var(--cursor-color);
            pointer-events: none;
            z-index: 10;
        }

        /* --- FOOTER / TRANSPORT --- */
        .transport-bar {
            background: var(--panel-color);
            padding: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            border-top: 1px solid #333;
        }

        .time-display {
            font-family: monospace;
            font-size: 1.2rem;
            color: var(--accent-color);
            min-width: 80px;
            text-align: center;
        }

        input[type="file"] {
            font-size: 0.8rem;
            color: #888;
        }
        
        .help-text {
            font-size: 0.8rem;
            color: #666;
            margin-left: auto;
        }
        
        /* Modal for Generator */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100;
            display: none; justify-content: center; align-items: center;
        }
        .modal {
            background: #222; padding: 20px; border-radius: 10px; width: 400px;
            text-align: center; border: 1px solid #444; color: #eee;
        }
        textarea {
            width: 100%; height: 100px; background: #111; color: #ddd; border: 1px solid #444;
            border-radius: 6px; padding: 10px; margin: 10px 0; font-family: sans-serif; resize: vertical;
        }
        input[type="password"] {
            width: 100%; background: #111; color: #ddd; border: 1px solid #444; padding: 8px; border-radius: 6px; margin-bottom: 10px;
        }

    </style>
</head>
<body>

    <!-- Smart Battle Gen Overlay -->
    <div id="genOverlay" class="modal-overlay">
        <div class="modal">
            <h3 style="margin-top:0">Analyzing Audio...</h3>
            <p id="genStatus">Reading file...</p>
            <div style="width:100%; background:#444; height:10px; border-radius:5px; margin-top:10px;">
                <div id="genBar" style="width:0%; background:var(--accent-color); height:100%; border-radius:5px;"></div>
            </div>
        </div>
    </div>

    <!-- AI Choreographer Modal -->
    <div id="aiModal" class="modal-overlay">
        <div class="modal">
            <h3 style="margin-top:0; color:var(--ai-color);">ü§ñ AI Choreographer</h3>
            
            <div style="text-align:left; margin-bottom:10px;">
                <label style="font-size:0.8rem; color:#aaa;">AI Provider:</label>
                <select id="aiProvider" style="width:100%; background:#111; color:white; border:1px solid #444; padding:5px; border-radius:4px;" onchange="updateAiConfig()">
                    <option value="openrouter">OpenRouter (DeepSeek/Mistral)</option>
                    <option value="openai">OpenAI (GPT-4o/Turbo)</option>
                </select>
            </div>

            <div style="text-align:left; margin-bottom:5px;">
                <label style="font-size:0.8rem; color:#aaa;" id="apiKeyLabel">OpenRouter API Key:</label>
                <input type="password" id="apiKey" placeholder="sk-..." onchange="saveKey()">
            </div>

            <div style="text-align:left;">
                <label style="font-size:0.8rem; color:#aaa;">Describe the Show:</label>
                <textarea id="aiPrompt" placeholder="Example: Star Wars battle. 0-10s silence. 10s Red Saber ignite (Mode 37). 30s fight starts with flashes. End with Fire (Mode 80)."></textarea>
            </div>

            <div style="display:flex; justify-content:space-between; margin-top:10px;">
                <button onclick="closeAiModal()">Cancel</button>
                <button class="ai" onclick="runAiGen()">Generate Show</button>
            </div>
            <p id="aiStatus" style="font-size:0.8rem; color:#aaa; margin-top:10px;"></p>
        </div>
    </div>

    <header>
        <div style="display:flex; align-items:center;">
            <h1>LightStudio</h1>
            <span id="connectionStatus" class="connection-status">Disconnected</span>
        </div>
        <div style="display:flex; gap:10px;">
            <button onclick="saveProject()">üíæ Save</button>
            <button onclick="document.getElementById('loadInput').click()">üìÇ Load</button>
            <input type="file" id="loadInput" accept=".json" style="display:none" onchange="loadProject(this)">
            
            <select id="protocolSelect" style="background:#333; color:white; border:none; padding:8px; border-radius:6px;">
                <option value="1">Protocol: Lotus (Most Common)</option>
                <option value="0">Protocol: ELK (Standard)</option>
                <option value="2">Protocol: Triones</option>
            </select>
            
            <button id="connectBtn" class="primary">üì° Connect</button>
        </div>
    </header>

    <div class="workspace">
        
        <!-- AUDIO LOAD -->
        <div style="display:flex; justify-content:space-between; align-items:center; background:#252525; padding:10px; border-radius:8px;">
            <div>
                <span style="font-size:0.8rem; color:#aaa; margin-right:10px;">üéµ Soundtrack:</span>
                <input type="file" id="audioFile" accept="audio/*">
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
                <button class="success" id="manualOnBtn">FORCE ON</button>
                <button class="danger" id="manualOffBtn">FORCE OFF</button>
                <span style="font-size:0.8rem; color:#aaa;">Zoom:</span>
                <input type="range" id="zoomRange" min="10" max="300" value="100" style="width:100px;">
            </div>
        </div>

        <!-- TOOLBAR -->
        <div class="toolbar">
            
            <div class="tool-group">
                <button class="tool-btn active" id="tool-select" onclick="setTool('select')" title="Select/Move/Delete (Backspace)">‚úã</button>
                <button class="tool-btn" onclick="selectAll()" title="Select All Events (Ctrl+A)">All</button>
            </div>

            <div class="tool-group">
                <input type="color" id="toolColor" value="#ff0000" title="Pick Color">
                <button class="tool-btn" id="tool-paint" onclick="setTool('paint')" title="Paint Color Block (Drag)">üñåÔ∏è</button>
            </div>

            <!-- MAGIC EFFECT TOOL -->
            <div class="tool-group">
                <button class="tool-btn" id="tool-magic" onclick="setTool('magic')" style="color:var(--magic-color);" title="Magic Effect Block">‚ú®</button>
                <div class="magic-controls" id="magicControls">
                    <div style="display:flex; gap:2px; align-items:center;">
                        <span style="font-size:0.6rem; color:#aaa;">Mode:</span>
                        <input type="number" id="magicMode" class="magic-input" min="1" max="200" value="1" title="Mode ID (1-200)">
                    </div>
                    <div style="display:flex; gap:2px; align-items:center;">
                        <span style="font-size:0.6rem; color:#aaa;">Spd:</span>
                        <input type="number" id="magicSpeed" class="magic-input" min="1" max="20" value="3" title="Speed (1=Fast)">
                    </div>
                </div>
            </div>

            <div class="tool-group">
                <button class="tool-btn" id="tool-flash" onclick="setTool('flash')" style="color:yellow;" title="Flash Event (Click)">‚ö°</button>
                <button class="tool-btn" id="tool-clash" onclick="setTool('clash')" style="color:white;" title="Clash Event (Click)">üí•</button>
                <button class="tool-btn" id="tool-off" onclick="setTool('off')" style="color:gray;" title="Turn Off Block (Drag)">‚ö´</button>
            </div>

            <div class="tool-group" style="border:none;">
                <button class="battle" onclick="startSmartGen()">‚ö° Smart Audio</button>
                <button class="ai" onclick="openAiModal()">ü§ñ AI Choreographer</button>
            </div>
            
            <div class="help-text" id="toolHelp">Use AI to script the battle</div>
        </div>

        <!-- TIMELINE -->
        <div class="timeline-container" id="timelineContainer">
            <div class="timeline-scroll-area" id="scrollArea">
                <canvas id="timelineCanvas"></canvas>
                <div id="playhead"></div>
            </div>
        </div>

    </div>

    <div class="transport-bar">
        <button onclick="stopPlayback()">‚èπ Stop</button>
        <button class="primary" id="playBtn" onclick="togglePlayback()" style="width: 100px;">‚ñ∂ Play</button>
        <div class="time-display" id="timeDisplay">00:00.0</div>
    </div>

    <!-- Hidden Audio Player -->
    <audio id="audioPlayer"></audio>

    <script>
        // --- CONSTANTS & CONFIG ---
        const PX_PER_SEC_BASE = 50; 
        let PX_PER_SEC = 100; 
        const TRACK_HEIGHT = 150;
        
        // --- STATE ---
        let events = []; 
        let currentTool = 'select';
        let isPlaying = false;
        let audioDuration = 60; 
        let waveformData = null; 
        let audioFileBuffer = null; 
        
        // --- BLUETOOTH STATE ---
        let device, characteristic;
        let currentProtocolIndex = 1; 
        let lastEventSent = null;

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('timelineCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('timelineContainer');
        const playhead = document.getElementById('playhead');
        const audioPlayer = document.getElementById('audioPlayer');
        const timeDisplay = document.getElementById('timeDisplay');
        const toolHelp = document.getElementById('toolHelp');
        const magicControls = document.getElementById('magicControls');

        // --- PROTOCOLS ---
        const PROTOCOLS = [
            { // 0: ELK
                name: "ELK",
                write: (r,g,b) => new Uint8Array([0x56, r, g, b, 0x00, 0xf0, 0xaa]),
                off: new Uint8Array([0xcc, 0x24, 0x33]),
                on: new Uint8Array([0xcc, 0x23, 0x33]),
                setMode: (m, s) => new Uint8Array([0xBB, m, s, 0x44])
            },
            { // 1: Lotus
                name: "Lotus",
                write: (r,g,b) => new Uint8Array([0x7e, 0x07, 0x05, 0x03, r, g, b, 0x10, 0xef]),
                off: new Uint8Array([0x7e, 0x04, 0x04, 0x00, 0x00, 0x00, 0xff, 0x00, 0xef]),
                on: new Uint8Array([0x7e, 0x04, 0x04, 0xf0, 0x00, 0x01, 0xff, 0x00, 0xef]),
                setMode: (m, s) => new Uint8Array([0x7e, 0x05, 0x03, m, s, 0xff, 0xff, 0x00, 0xef])
            },
            { // 2: Triones
                name: "Triones",
                write: (r,g,b) => new Uint8Array([0x56, r, g, b, 0x00, 0xf0, 0xaa]),
                off: new Uint8Array([0xcc, 0x24, 0x33]),
                on: new Uint8Array([0xcc, 0x23, 0x33]),
                setMode: (m, s) => new Uint8Array([0xBB, m, s, 0x44])
            }
        ];

        // --- INITIALIZATION ---
        function resizeCanvas() {
            canvas.height = container.clientHeight;
            canvas.width = Math.max(container.clientWidth, audioDuration * PX_PER_SEC);
            drawTimeline();
        }
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('zoomRange').addEventListener('input', (e) => {
            PX_PER_SEC = parseInt(e.target.value);
            resizeCanvas();
        });

        document.getElementById('protocolSelect').addEventListener('change', (e) => {
            currentProtocolIndex = parseInt(e.target.value);
        });

        // --- AI CHOREOGRAPHER ---
        window.openAiModal = function() {
            document.getElementById('aiModal').style.display = 'flex';
            const provider = localStorage.getItem('ai_provider') || 'openrouter';
            document.getElementById('aiProvider').value = provider;
            updateAiConfig();
        }
        
        window.updateAiConfig = function() {
            const provider = document.getElementById('aiProvider').value;
            const label = document.getElementById('apiKeyLabel');
            const input = document.getElementById('apiKey');
            
            localStorage.setItem('ai_provider', provider);
            
            if(provider === 'openai') {
                label.innerText = "OpenAI API Key:";
                input.placeholder = "sk-proj-...";
                input.value = localStorage.getItem('openai_key') || '';
            } else {
                label.innerText = "OpenRouter API Key:";
                input.placeholder = "sk-or-v1-...";
                input.value = localStorage.getItem('openrouter_key') || '';
            }
        }

        window.closeAiModal = function() {
            document.getElementById('aiModal').style.display = 'none';
        }
        
        window.saveKey = function() {
            const provider = document.getElementById('aiProvider').value;
            const key = document.getElementById('apiKey').value;
            if(provider === 'openai') localStorage.setItem('openai_key', key);
            else localStorage.setItem('openrouter_key', key);
        }

        window.runAiGen = async function() {
            const provider = document.getElementById('aiProvider').value;
            const key = document.getElementById('apiKey').value;
            const userPrompt = document.getElementById('aiPrompt').value;
            const status = document.getElementById('aiStatus');
            
            if(!key) return alert("API Key required");
            if(!userPrompt) return alert("Please describe the scene");
            
            if(userPrompt.length > 5000) return alert("Description too long! Keep it under 5000 chars.");

            status.innerText = "Generating... (This may take a moment)";
            
            // OPTIMIZED SYSTEM PROMPT (Reduced tokens)
            const systemPrompt = `
            Act as a Lighting Designer. Audio Duration: ${Math.floor(audioDuration)}s.
            Return ONLY a valid JSON array of events. No text.
            
            Event Schema: 
            { "id": number, "type": "color"|"flash"|"clash"|"off"|"magic", "start": number, "duration": number, "color": "#hex", "mode": number, "speed": number }
            
            Types:
            - flash: duration 0.1s, #ffff00 (Strike)
            - clash: duration 0.2s, #ffffff (Explosion)
            - off: Blackout
            - magic: Built-in Pattern (requires 'mode' & 'speed')
            
            Mode Library (IDs):
            - 1: Rainbow
            - 37: Red Stack (Sith)
            - 38: Green Stack (Yoda)
            - 39: Blue Stack (Jedi)
            - 181/183: Alt Red/Blue Fills
            - 80: Fire/Lava
            - 95: Strobe
            
            Rules:
            - Cover the timeline.
            - Use 'magic' for intros/special.
            - Use 'color'/'flash' for battles.
            `;

            let url, body, headers;
            
            if (provider === 'openai') {
                url = 'https://api.openai.com/v1/chat/completions';
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                };
                body = JSON.stringify({
                    model: "gpt-4o-mini", // Cost efficient, high context
                    messages: [
                        {role: "system", content: systemPrompt},
                        {role: "user", content: userPrompt}
                    ],
                    temperature: 0.7,
                    max_tokens: 4000 // Prevent context overflow
                });
            } else {
                url = 'https://openrouter.ai/api/v1/chat/completions';
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`,
                    'HTTP-Referer': window.location.href,
                    'X-Title': 'LightShowStudio'
                };
                body = JSON.stringify({
                    model: "deepseek/deepseek-chat",
                    messages: [
                        {role: "system", content: systemPrompt},
                        {role: "user", content: userPrompt}
                    ],
                    temperature: 0.7,
                    max_tokens: 4000 // Prevent context overflow
                });
            }

            try {
                const response = await fetch(url, { method: 'POST', headers: headers, body: body });
                const data = await response.json();
                
                if(data.error) throw new Error(data.error.message || JSON.stringify(data.error));
                
                let content = data.choices[0].message.content;
                // Cleanup Markdown
                if (content.includes("```")) {
                    content = content.replace(/```json/g, '').replace(/```/g, '');
                }
                
                const newEvents = JSON.parse(content);
                
                // Fix IDs and Selection
                newEvents.forEach(e => {
                    e.id = Date.now() + Math.random();
                    e.selected = false;
                    // defaults
                    if(!e.color) e.color = "#000000";
                    if(e.type === 'magic' && !e.speed) e.speed = 3;
                });
                
                if(confirm(`Generated ${newEvents.length} events. Load to timeline?`)) {
                    events = newEvents;
                    drawTimeline();
                    closeAiModal();
                }
                status.innerText = "";

            } catch(e) {
                console.error(e);
                status.innerText = "Error: " + e.message;
            }
        }

        // --- SMART GENERATOR (DSP) ---
        window.startSmartGen = async function() {
            if(!audioFileBuffer) return alert("Please load an audio file first!");
            if(!confirm("Generate new Battle Sequence based on audio analysis?")) return;
            
            const overlay = document.getElementById('genOverlay');
            const status = document.getElementById('genStatus');
            const bar = document.getElementById('genBar');
            overlay.style.display = 'flex';
            status.innerText = "Analyzing Ignition & Frequencies...";
            await new Promise(r => setTimeout(r, 100));
            
            try {
                const rawData = audioFileBuffer.getChannelData(0);
                const sampleRate = audioFileBuffer.sampleRate;
                events = []; 
                
                // 1. Ignition Detection
                let ignitionIndex = 0;
                const silenceThresh = 0.05; 
                for(let i=0; i<rawData.length; i+=100) {
                    if(Math.abs(rawData[i]) > silenceThresh) { ignitionIndex = i; break; }
                }
                const ignitionTime = ignitionIndex / sampleRate;
                
                if(ignitionTime > 0.1) {
                    events.push({ id: Date.now(), type: 'off', start: 0, duration: ignitionTime, color: '#000000', selected: false });
                }
                
                status.innerText = `Found Ignition at ${ignitionTime.toFixed(1)}s. Generating...`;
                
                // 2. Battle Generation
                const chunkDur = 0.5; 
                const chunkSamples = Math.floor(sampleRate * chunkDur);
                let currentTime = ignitionTime;
                let bufferIndex = ignitionIndex;
                
                while (bufferIndex < rawData.length) {
                    const end = Math.min(bufferIndex + chunkSamples, rawData.length);
                    const chunk = rawData.slice(bufferIndex, end);
                    let maxVol = 0;
                    let crossings = 0;
                    for(let j=0; j<chunk.length; j++) {
                        const val = chunk[j];
                        if(Math.abs(val) > maxVol) maxVol = Math.abs(val);
                        if(j > 0 && val >= 0 && chunk[j-1] < 0) crossings++;
                    }
                    const zcr = crossings / chunk.length;
                    
                    if (maxVol > 0.8) {
                        const type = (Math.random() > 0.5) ? 'clash' : 'flash';
                        events.push({ id: Date.now()+currentTime, type: type, start: currentTime, duration: 0.15, color: type === 'clash' ? '#ffffff' : '#ffff00', selected: false });
                    } else if (maxVol > 0.1) {
                        const isVader = zcr < 0.05; 
                        const color = isVader ? '#ff0000' : '#0000ff';
                        events.push({ id: Date.now()+currentTime, type: 'color', start: currentTime, duration: chunkDur, color: color, selected: false });
                    }
                    currentTime += chunkDur;
                    bufferIndex += chunkSamples;
                    bar.style.width = `${(bufferIndex/rawData.length)*100}%`;
                }
                drawTimeline();
            } catch(e) { alert("Error: " + e.message); }
            overlay.style.display = 'none';
        }

        window.generateFireSequence = function() {
            if(!confirm("Clear timeline and generate Fire?")) return;
            events = [];
            const duration = Math.min(audioDuration, 300);
            let t = 0;
            const fireColors = ['#ff0000', '#ff4500', '#ff8c00', '#ffa500']; 
            while(t < duration) {
                const dur = 0.05 + Math.random() * 0.15; 
                const col = fireColors[Math.floor(Math.random() * fireColors.length)];
                events.push({ id: Date.now() + Math.random(), type: 'color', start: t, duration: dur, color: col, selected: false });
                t += dur;
            }
            drawTimeline();
        }

        window.selectAll = function() { events.forEach(ev => ev.selected = true); drawTimeline(); }

        // --- TOOL LOGIC ---
        window.setTool = function(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('tool-'+tool);
            if(btn) btn.classList.add('active');
            if(tool === 'magic') magicControls.classList.add('visible');
            else magicControls.classList.remove('visible');
            const help = { 'select': 'Drag to Move. Edge to Resize.', 'paint': 'Paint COLOR block.', 'magic': 'Paint PATTERN block.', 'flash': 'Insert FLASH.', 'clash': 'Insert CLASH.', 'off': 'Paint OFF block.' };
            toolHelp.innerText = help[tool] || '';
        };

        // --- AUDIO HANDLING ---
        document.getElementById('audioFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            audioPlayer.src = url;
            const arrayBuffer = await file.arrayBuffer();
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioFileBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            audioDuration = audioFileBuffer.duration;
            const rawData = audioFileBuffer.getChannelData(0);
            const samples = 2000; 
            const blockSize = Math.floor(rawData.length / samples);
            waveformData = new Float32Array(samples);
            for(let i=0; i<samples; i++) {
                let sum = 0;
                for(let j=0; j<blockSize; j++) sum += Math.abs(rawData[i*blockSize + j]);
                waveformData[i] = sum / blockSize;
            }
            resizeCanvas();
        });

        // --- CANVAS INTERACTION ---
        let isDragging = false;
        let dragStartTime = 0;
        let dragAction = null; 
        let dragTarget = null; 

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const time = x / PX_PER_SEC;
            
            if (currentTool === 'select') {
                const clickedEvent = events.find(ev => time >= ev.start && time <= ev.start + ev.duration);
                if (clickedEvent) {
                    if (!e.ctrlKey && !clickedEvent.selected) events.forEach(ev => ev.selected = false);
                    clickedEvent.selected = true;
                    isDragging = true;
                    dragAction = 'move';
                    dragStartTime = time;
                    dragTarget = clickedEvent;
                    const selectedCount = events.filter(ev => ev.selected).length;
                    if (selectedCount === 1) {
                        const edgeThreshold = 5 / PX_PER_SEC; 
                        if (Math.abs(time - clickedEvent.start) < edgeThreshold) dragAction = 'resize-left';
                        else if (Math.abs(time - (clickedEvent.start + clickedEvent.duration)) < edgeThreshold) dragAction = 'resize-right';
                    }
                } else {
                    if (!e.ctrlKey) {
                        events.forEach(ev => ev.selected = false);
                        audioPlayer.currentTime = time;
                        updatePlayhead();
                    }
                }
            } 
            else if (['paint', 'off', 'magic'].includes(currentTool)) {
                events.forEach(ev => ev.selected = false);
                isDragging = true;
                dragAction = 'create';
                dragStartTime = time;
                let color = '#000000'; let mode = null; let speed = null;
                if (currentTool === 'paint') color = document.getElementById('toolColor').value;
                if (currentTool === 'magic') { color = '#8b5cf6'; mode = parseInt(document.getElementById('magicMode').value); speed = parseInt(document.getElementById('magicSpeed').value); }
                const newEvent = { id: Date.now(), type: currentTool, start: time, duration: 0.5, color: color, mode: mode, speed: speed, selected: true };
                events.push(newEvent);
                dragTarget = newEvent;
            }
            else if (['flash', 'clash'].includes(currentTool)) {
                events.forEach(ev => ev.selected = false);
                const newEvent = { id: Date.now(), type: currentTool, start: time, duration: 0.15, color: currentTool === 'flash' ? '#ffff00' : '#ffffff', selected: true };
                events.push(newEvent);
            }
            drawTimeline();
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            if (x < 0) x = 0; 
            const time = Math.max(0, x / PX_PER_SEC);
            const dt = time - dragStartTime;
            if (dragAction === 'move') { events.forEach(ev => { if (ev.selected) ev.start += dt; }); dragStartTime = time; } 
            else if (dragAction === 'resize-right' || dragAction === 'create') { let newDur = time - dragTarget.start; if(newDur < 0.1) newDur = 0.1; dragTarget.duration = newDur; }
            else if (dragAction === 'resize-left') { const end = dragTarget.start + dragTarget.duration; let newStart = time; if (newStart > end - 0.1) newStart = end - 0.1; dragTarget.duration = end - newStart; dragTarget.start = newStart; }
            drawTimeline();
        });

        window.addEventListener('mouseup', () => { isDragging = false; dragTarget = null; dragAction = null; });
        
        window.addEventListener('keydown', (e) => {
            // IGNORE SPACEBAR IF TYPING
            const tag = e.target.tagName.toLowerCase();
            if (tag === 'input' || tag === 'textarea') return;

            if (e.key === 'Backspace' || e.key === 'Delete') { events = events.filter(ev => !ev.selected); drawTimeline(); }
            if (e.code === 'Space') { e.preventDefault(); togglePlayback(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') { e.preventDefault(); selectAll(); }
        });

        // --- DRAWING ---
        function drawTimeline() {
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (waveformData) {
                ctx.fillStyle = '#333';
                const step = canvas.width / waveformData.length;
                const mid = canvas.height / 2;
                const scale = canvas.height * 0.4;
                ctx.beginPath();
                for(let i=0; i<waveformData.length; i++) {
                    const x = i * step;
                    const h = waveformData[i] * scale;
                    ctx.rect(x, mid - h, step, h*2);
                }
                ctx.fill();
            }
            ctx.strokeStyle = '#444'; ctx.lineWidth = 1; ctx.beginPath();
            for(let sec = 0; sec < audioDuration; sec++) {
                const x = sec * PX_PER_SEC; ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.fillStyle = '#666'; ctx.fillText(sec + 's', x + 5, 12);
            }
            ctx.stroke();
            events.forEach(ev => {
                const x = ev.start * PX_PER_SEC; const w = ev.duration * PX_PER_SEC; const y = 30; const h = 80;
                ctx.fillStyle = ev.color;
                if (ev.type === 'off') { ctx.fillStyle = '#111'; ctx.strokeStyle = '#555'; ctx.setLineDash([5, 5]); ctx.strokeRect(x, y, w, h); ctx.setLineDash([]); ctx.fillRect(x, y, w, h); } 
                else if (ev.type === 'magic') { ctx.fillStyle = '#8b5cf6'; ctx.fillRect(x, y, w, h); ctx.fillStyle = 'white'; ctx.font = '12px sans-serif'; ctx.fillText(`M:${ev.mode}`, x + 5, y + 20); } 
                else if (ev.type === 'flash' || ev.type === 'clash') { const grad = ctx.createLinearGradient(x, y, x, y+h); grad.addColorStop(0, '#fff'); grad.addColorStop(1, ev.color); ctx.fillStyle = grad; ctx.fillRect(x, y, w, h); } 
                else { ctx.fillRect(x, y, w, h); }
                if (ev.selected) { ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h); }
                ctx.fillStyle = (ev.type === 'off' || ev.color === '#000000') ? '#aaa' : 'black';
                ctx.font = '10px sans-serif';
                ctx.fillText(ev.type.toUpperCase(), x + 3, y + 12);
            });
        }

        // --- PLAYBACK ENGINE ---
        function togglePlayback() { if (isPlaying) stopPlayback(); else startPlayback(); }
        function startPlayback() {
            if(!audioPlayer.src) return alert("Load Audio First!");
            isPlaying = true;
            audioPlayer.play();
            document.getElementById('playBtn').innerText = '‚è∏ Pause';
            requestAnimationFrame(playbackLoop);
        }
        function stopPlayback() {
            isPlaying = false;
            audioPlayer.pause();
            document.getElementById('playBtn').innerText = '‚ñ∂ Play';
            if(characteristic) {
                const p = PROTOCOLS[currentProtocolIndex];
                characteristic.writeValue(p.off).catch(e=>{});
            }
        }

        function playbackLoop() {
            if (!isPlaying) return;
            const t = audioPlayer.currentTime;
            updatePlayhead();
            const activeEvents = events.filter(ev => t >= ev.start && t < (ev.start + ev.duration));
            let eventToSend = null;
            if(activeEvents.length > 0) {
                const priority = { 'clash': 4, 'flash': 3, 'magic': 2, 'off': 1, 'color': 0, 'paint': 0 };
                activeEvents.sort((a,b) => priority[b.type] - priority[a.type]);
                eventToSend = activeEvents[0];
            }
            if (eventToSend) {
                if (eventToSend.id !== lastEventSent) {
                    sendEvent(eventToSend);
                    lastEventSent = eventToSend.id;
                }
            } else { if (lastEventSent !== null) lastEventSent = null; }
            requestAnimationFrame(playbackLoop);
        }

        function updatePlayhead() {
            const t = audioPlayer.currentTime;
            const x = t * PX_PER_SEC;
            playhead.style.transform = `translateX(${x}px)`;
            const scrollL = container.scrollLeft;
            const width = container.clientWidth;
            if (x > scrollL + width * 0.8) container.scrollLeft = x - width * 0.2;
            const mins = Math.floor(t / 60);
            const secs = Math.floor(t % 60).toString().padStart(2, '0');
            const ms = Math.floor((t % 1) * 10);
            timeDisplay.innerText = `${mins}:${secs}.${ms}`;
        }

        // --- BLUETOOTH LOGIC ---
        async function sendEvent(ev) {
            if (!characteristic) return;
            const p = PROTOCOLS[currentProtocolIndex];
            try {
                if (ev.type === 'off') { await characteristic.writeValue(p.off); } 
                else if (ev.type === 'magic') {
                    if(p.setMode) {
                        if(p.on) await characteristic.writeValue(p.on);
                        await characteristic.writeValue(p.setMode(ev.mode, ev.speed));
                    }
                } else {
                    const hex = ev.color;
                    const r = parseInt(hex.substring(1, 3), 16);
                    const g = parseInt(hex.substring(3, 5), 16);
                    const b = parseInt(hex.substring(5, 7), 16);
                    const colorData = p.write(r, g, b);
                    if(p.on) await characteristic.writeValue(p.on);
                    await characteristic.writeValue(colorData);
                }
            } catch (err) {}
        }
        
        document.getElementById('manualOffBtn').addEventListener('click', () => { if(characteristic) characteristic.writeValue(PROTOCOLS[currentProtocolIndex].off).catch(e=>{}); });
        document.getElementById('manualOnBtn').addEventListener('click', () => { if(characteristic) characteristic.writeValue(PROTOCOLS[currentProtocolIndex].on).catch(e=>{}); });

        document.getElementById('connectBtn').addEventListener('click', async () => {
            const status = document.getElementById('connectionStatus');
            try {
                if (!navigator.bluetooth) throw new Error("Browser not supported.");
                status.innerText = "Scanning...";
                device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['0000ffd5-0000-1000-8000-00805f9b34fb', '0000ffe5-0000-1000-8000-00805f9b34fb', '0000fff0-0000-1000-8000-00805f9b34fb']
                });
                const server = await device.gatt.connect();
                let service;
                const uuids = ['0000ffd5-0000-1000-8000-00805f9b34fb', '0000ffe5-0000-1000-8000-00805f9b34fb', '0000fff0-0000-1000-8000-00805f9b34fb'];
                for(let u of uuids) { try { service = await server.getPrimaryService(u); break; } catch(e){} }
                if(!service) throw new Error("Service not found");
                const charUUIDs = ['0000ffd9-0000-1000-8000-00805f9b34fb', '0000ffe9-0000-1000-8000-00805f9b34fb', '0000fff3-0000-1000-8000-00805f9b34fb'];
                for(let c of charUUIDs) { try { characteristic = await service.getCharacteristic(c); break; } catch(e){} }
                if (characteristic) {
                    status.innerText = "Connected";
                    status.classList.add('connected');
                    document.getElementById('connectBtn').style.display = 'none';
                }
            } catch (err) { alert("Connection failed: " + err.message); status.innerText = "Error"; }
        });

        window.saveProject = function() {
            const data = JSON.stringify(events);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'lightshow.json'; a.click();
        };

        window.loadProject = function(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try { events = JSON.parse(e.target.result); drawTimeline(); } catch(err) { alert("Invalid File"); }
            };
            reader.readAsText(file);
        };

        resizeCanvas();
    </script>
</body>
</html>
